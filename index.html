<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Baby Maze Hunt</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #faf3e0;
      height: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
      font-family: 'Segoe UI', Arial, sans-serif;
    }
    canvas {
      background: linear-gradient(#fff, #f0f0f0);
      border: 2px solid #333;
      box-shadow: 0 20px 30px rgba(0,0,0,0.3);
    }
    #gameOver {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 2rem;
      font-size: 2rem;
      display: none;
    }
    #restart {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      padding: 0.5rem 1rem;
      font-size: 1.2rem;
      cursor: pointer;
      background: #4caf50;
      color: white;
      border: none;
      border-radius: 4px;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas" width="600" height="600"></canvas>
  <div id="instructions" style="position:absolute;top:10px;left:50%;transform:translateX(-50%);background:rgba(0,0,0,0.7);color:#fff;padding:0.5rem 1rem;border-radius:4px;">Click or use arrow keys to move the baby and eat food!</div>
  <div id="gameOver">😭 Baby is crying! Game Over!</div>
  <div id="success" style="display:none; position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); background:rgba(0,0,0,0.7); color:#fff; padding:2rem; font-size:2rem;">You Succeeded!</div>
  <button id="restart">Start Game</button>
  <button id="nextStage" style="display:none; position:absolute; top:60%; left:50%; transform:translate(-50%,-50%); padding:0.5rem 1rem; font-size:1.2rem; cursor:pointer; background:#2196f3; color:white; border:none; border-radius:4px;">Start Stage 2</button>
  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const gameOverEl = document.getElementById('gameOver');
    const restartBtn = document.getElementById('restart');
    const successEl = document.getElementById('success');
    const nextStageBtn = document.getElementById('nextStage');

    const STAGE1_GRID = [
      [1,1,1,1,1,1,1,1,1,1],
      [1,0,0,0,1,0,0,0,0,1],
      [1,0,1,0,1,0,1,1,0,1],
      [1,0,1,0,0,0,0,1,0,1],
      [1,0,1,1,1,1,0,1,0,1],
      [1,0,0,0,0,1,0,1,0,1],
      [1,1,1,1,0,1,0,1,0,1],
      [1,0,0,1,0,0,0,1,0,1],
      [1,0,0,0,0,1,0,0,0,1],
      [1,1,1,1,1,1,1,1,1,1]
    ];
    const STAGE2_GRID = [
      [1,1,1,1,1,1,1,1,1,1],
      [1,0,0,1,0,0,0,1,0,1],
      [1,0,1,1,0,1,0,1,0,1],
      [1,0,1,0,0,0,0,0,0,1],
      [1,0,1,0,1,1,1,1,0,1],
      [1,0,0,0,0,1,0,1,0,1],
      [1,1,1,1,0,1,1,1,0,1],
      [1,0,0,0,0,0,0,1,0,1],
      [1,0,1,1,1,1,0,0,0,1],
      [1,1,1,1,1,1,1,1,1,1]
    ];
    let GRID = STAGE1_GRID;
    let TILE;
    const INITIAL_SPEED = 3;
    const FOOD_EMOJIS = ['🍎','🍌','🥕','🍇','🍉','🍞','🍪','🍔','🍕','🍗','🍚','🍩','🍿','🍼','🥛','🥤'];
    let baby, food, timerId, timeStart, score, gameOver;
    let currentFoodEmoji = '🍎';
    let babyEmoji = '👶';
    let currentStage = 1;

    function resizeCanvas() {
      const size = Math.min(window.innerWidth, window.innerHeight);
      canvas.width = size;
      canvas.height = size;
      TILE = canvas.width / GRID.length;
    }

    window.addEventListener('resize', resizeCanvas);

    function init() {
      resizeCanvas();
      baby = { x: TILE + TILE/2, y: TILE + TILE/2, r: 15, vx:0, vy:0, speed: INITIAL_SPEED };
      spawnFood();
      timeStart = Date.now();
      score = 0;
      gameOver = false;
      gameOverEl.style.display = 'none';
      restartBtn.style.display = 'none';
      successEl.style.display = 'none';
      nextStageBtn.style.display = 'none';
      clearTimeout(timerId);
      timerId = setTimeout(endGame, 13000);
      requestAnimationFrame(loop);
    }

    function spawnFood() {
      let gx, gy;
      do {
        gx = Math.floor(Math.random() * GRID.length);
        gy = Math.floor(Math.random() * GRID.length);
      } while (GRID[gy][gx] !== 0);
      const size = Math.max(12, Math.round(baby.r * 0.8));
      food = { x: gx * TILE + TILE/2, y: gy * TILE + TILE/2, r: size };
      currentFoodEmoji = FOOD_EMOJIS[Math.floor(Math.random() * FOOD_EMOJIS.length)];
      timeStart = Date.now();
    }

    function screenToBoard(sx, sy) {
      return { x: sx, y: sy };
    }

    canvas.addEventListener('click', e => {
      if (gameOver) return;
      const rect = canvas.getBoundingClientRect();
      const tx = e.clientX - rect.left;
      const ty = e.clientY - rect.top;
      const boardPos = screenToBoard(tx, ty);
      const dx = boardPos.x - baby.x;
      const dy = boardPos.y - baby.y;
      if (Math.abs(dx) > Math.abs(dy)) {
        baby.vx = dx > 0 ? baby.speed : -baby.speed;
        baby.vy = 0;
      } else {
        baby.vx = 0;
        baby.vy = dy > 0 ? baby.speed : -baby.speed;
      }
    });

    document.addEventListener('keydown', e => {
      if (gameOver) return;
      switch(e.key) {
        case 'ArrowLeft':
        case 'a':
          baby.vx = -baby.speed; baby.vy = 0; break;
        case 'ArrowRight':
        case 'd':
          baby.vx = baby.speed; baby.vy = 0; break;
        case 'ArrowUp':
        case 'w':
          baby.vy = -baby.speed; baby.vx = 0; break;
        case 'ArrowDown':
        case 's':
          baby.vy = baby.speed; baby.vx = 0; break;
      }
    });

    function startGame() {
      if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen().catch(() => {});
      }
      currentStage = 1;
      GRID = STAGE1_GRID;
      successEl.style.display = 'none';
      nextStageBtn.style.display = 'none';
      document.getElementById('instructions').style.display = 'none';
      init();
    }

    restartBtn.addEventListener('click', startGame);
    nextStageBtn.addEventListener('click', startStage2);

    function startStage2() {
      currentStage = 2;
      GRID = STAGE2_GRID;
      successEl.style.display = 'none';
      nextStageBtn.style.display = 'none';
      document.getElementById('instructions').style.display = 'none';
      init();
    }

    function isWall(x, y) {
      const gx = Math.floor(x / TILE);
      const gy = Math.floor(y / TILE);
      return GRID[gy] && GRID[gy][gx] === 1;
    }

    function update() {
      if (!gameOver) {
        const nextX = baby.x + baby.vx;
        const nextY = baby.y + baby.vy;
        if (!isWall(nextX, baby.y)) baby.x = nextX;
        else baby.vx = 0;
        if (!isWall(baby.x, nextY)) baby.y = nextY;
        else baby.vy = 0;
        const d = Math.hypot(baby.x - food.x, baby.y - food.y);
        if (d < baby.r + food.r) {
          baby.r += 2;
          baby.speed += 0.5;
          score += 1;
          if (score >= 10 && currentStage === 1) {
            gameOver = true;
            successEl.style.display = 'block';
            nextStageBtn.style.display = 'block';
            babyEmoji = '👶';
            clearTimeout(timerId);
            return;
          }
          babyEmoji = '😊';
          setTimeout(() => { babyEmoji = '👶'; }, 800);
          clearTimeout(timerId);
          spawnFood();
          timerId = setTimeout(endGame, 13000);
        }
      }
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.save();

      // draw cells
      for (let y = 0; y < GRID.length; y++) {
        for (let x = 0; x < GRID[y].length; x++) {
          ctx.fillStyle = GRID[y][x] === 1 ? '#444' : '#ddd';
          ctx.fillRect(x * TILE, y * TILE, TILE, TILE);
        }
      }
      // grid lines
      ctx.strokeStyle = '#aaa'; ctx.lineWidth = 1;
      for (let i = 0; i <= GRID.length; i++) {
        ctx.beginPath(); ctx.moveTo(i * TILE, 0); ctx.lineTo(i * TILE, GRID.length * TILE); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(0, i * TILE); ctx.lineTo(GRID.length * TILE, i * TILE); ctx.stroke();
      }
      // draw food as emoji
      if (!gameOver) {
        ctx.font = `${food.r * 2}px sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(currentFoodEmoji, food.x, food.y);
      }
      // draw baby as emoji
      ctx.font = `${baby.r * 2}px sans-serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(babyEmoji, baby.x, baby.y);

      ctx.restore();

      // HUD
      const timeLeft = Math.max(0, 13 - Math.floor((Date.now() - timeStart) / 1000));
      ctx.fillStyle = '#000'; ctx.font = '16px Arial';
      ctx.fillText(`Time: ${timeLeft}s`, 10, 20);
      ctx.fillText(`Score: ${score}`, 10, 40);
    }

    function loop() {
      update(); draw();
      if (!gameOver) requestAnimationFrame(loop);
    }

    function endGame() {
      gameOver = true;
      gameOverEl.style.display = 'block';
      restartBtn.style.display = 'block';
    }

    document.addEventListener('DOMContentLoaded', () => {
      restartBtn.style.display = 'block';
    });
  </script>
</body>
</html>
